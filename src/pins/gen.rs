//! Types generated by a macro

use core::marker::PhantomData;

use super::{pin::Pin, state, traits::Trait};

macro_rules! pins {
    ($(
        $field:ident, // e.g. pio0_0
        $type:ident,  // e.g. PIO0_0
        $port:expr,
        $id:expr,     // e.g. 0x00
        $default_state_ty:ty;
    )*) => {
        /// Provides access to all pins
        ///
        /// You can get access to an instance of this struct through
        ///[`Peripherals`].
        ///
        /// # Limitations
        ///
        /// This struct currently provides access to all pins that can be
        /// available on an LPC8xx part. Please make sure that you are aware of
        /// which pins are actually available on your specific part, and only
        /// use those.
        ///
        /// [`Peripherals`]: ../struct.Peripherals.html
        #[allow(missing_docs)]
        pub struct Pins {
            $(pub $field: Pin<$type, $default_state_ty>,)*
        }

        impl Pins {
            pub(crate) fn new() -> Self {
                Pins {
                    $(
                        $field: Pin {
                            ty:     $type(()),
                            _state: <$default_state_ty>::new(),
                        },
                    )*
                }
            }
        }


        $(
            /// Identifies a specific pin
            ///
            /// This type is used as a type parameter on [`Pin`]. Check out
            /// [`Pin`]'s documentation for more information.
            ///
            /// [`Pin`]: struct.Pin.html
            #[allow(non_camel_case_types)]
            pub struct $type(());

            impl Trait for $type {
                fn port(&self) -> u8 {
                    $port
                }

                fn id(&self) -> u8 {
                    $id
                }

                fn mask(&self) -> u32 {
                    0x1 << $id
                }
            }
        )*


        /// Contains a token for each pin
        ///
        /// This is used by the GPIO API to uphold certain guarantees regarding
        /// pins. Please refer to [`GPIO`] for more information.
        ///
        /// [`GPIO`]: ../gpio/struct.GPIO.html
        pub struct Tokens<State> {
            $(
                /// A token representing a pin
                pub $field: Token<$type, State>,
            )*
        }

        impl<State> Tokens<State> {
            pub(crate) fn new() -> Self {
                Self {
                    $(
                        $field: Token(PhantomData, PhantomData),
                    )*
                }
            }

            /// Switches the state of all tokens
            ///
            /// Since this consumes `self`, it can only be called if all tokens
            /// are available.
            pub(crate) fn switch_state<NewState>(self) -> Tokens<NewState> {
                Tokens {
                    $(
                        $field: Token(self.$field.0, PhantomData),
                    )*
                }
            }
        }

        /// A token representing a pin.
        ///
        /// Used by [`GPIO`] to uphold correctness guarantees. Please refer to
        /// [`GPIO`] for more information.
        ///
        /// [`GPIO`]: ../gpio/struct.GPIO.html
        pub struct Token<Pin, State>(PhantomData<Pin>, PhantomData<State>);
    }
}

#[cfg(feature = "82x")]
pins!(
    pio0_0 , PIO0_0 , 0, 0x00, state::Unused;
    pio0_1 , PIO0_1 , 0, 0x01, state::Unused;
    pio0_2 , PIO0_2 , 0, 0x02, state::Swm<((),), ()>;
    pio0_3 , PIO0_3 , 0, 0x03, state::Swm<((),), ()>;
    pio0_4 , PIO0_4 , 0, 0x04, state::Unused;
    pio0_5 , PIO0_5 , 0, 0x05, state::Swm<(), ((),)>;
    pio0_6 , PIO0_6 , 0, 0x06, state::Unused;
    pio0_7 , PIO0_7 , 0, 0x07, state::Unused;
    pio0_8 , PIO0_8 , 0, 0x08, state::Unused;
    pio0_9 , PIO0_9 , 0, 0x09, state::Unused;
    pio0_10, PIO0_10, 0, 0x0a, state::Unused;
    pio0_11, PIO0_11, 0, 0x0b, state::Unused;
    pio0_12, PIO0_12, 0, 0x0c, state::Unused;
    pio0_13, PIO0_13, 0, 0x0d, state::Unused;
    pio0_14, PIO0_14, 0, 0x0e, state::Unused;
    pio0_15, PIO0_15, 0, 0x0f, state::Unused;
    pio0_16, PIO0_16, 0, 0x10, state::Unused;
    pio0_17, PIO0_17, 0, 0x11, state::Unused;
    pio0_18, PIO0_18, 0, 0x12, state::Unused;
    pio0_19, PIO0_19, 0, 0x13, state::Unused;
    pio0_20, PIO0_20, 0, 0x14, state::Unused;
    pio0_21, PIO0_21, 0, 0x15, state::Unused;
    pio0_22, PIO0_22, 0, 0x16, state::Unused;
    pio0_23, PIO0_23, 0, 0x17, state::Unused;
    pio0_24, PIO0_24, 0, 0x18, state::Unused;
    pio0_25, PIO0_25, 0, 0x19, state::Unused;
    pio0_26, PIO0_26, 0, 0x1a, state::Unused;
    pio0_27, PIO0_27, 0, 0x1b, state::Unused;
    pio0_28, PIO0_28, 0, 0x1c, state::Unused;
);

#[cfg(feature = "845")]
pins!(
    pio0_0 , PIO0_0 , 0, 0x00, state::Unused;
    pio0_1 , PIO0_1 , 0, 0x01, state::Unused;
    pio0_2 , PIO0_2 , 0, 0x02, state::Swm<((),), ()>;
    pio0_3 , PIO0_3 , 0, 0x03, state::Swm<((),), ()>;
    pio0_4 , PIO0_4 , 0, 0x04, state::Unused;
    pio0_5 , PIO0_5 , 0, 0x05, state::Swm<(), ((),)>;
    pio0_6 , PIO0_6 , 0, 0x06, state::Unused;
    pio0_7 , PIO0_7 , 0, 0x07, state::Unused;
    pio0_8 , PIO0_8 , 0, 0x08, state::Unused;
    pio0_9 , PIO0_9 , 0, 0x09, state::Unused;
    pio0_10, PIO0_10, 0, 0x0a, state::Unused;
    pio0_11, PIO0_11, 0, 0x0b, state::Unused;
    pio0_12, PIO0_12, 0, 0x0c, state::Unused;
    pio0_13, PIO0_13, 0, 0x0d, state::Unused;
    pio0_14, PIO0_14, 0, 0x0e, state::Unused;
    pio0_15, PIO0_15, 0, 0x0f, state::Unused;
    pio0_16, PIO0_16, 0, 0x10, state::Unused;
    pio0_17, PIO0_17, 0, 0x11, state::Unused;
    pio0_18, PIO0_18, 0, 0x12, state::Unused;
    pio0_19, PIO0_19, 0, 0x13, state::Unused;
    pio0_20, PIO0_20, 0, 0x14, state::Unused;
    pio0_21, PIO0_21, 0, 0x15, state::Unused;
    pio0_22, PIO0_22, 0, 0x16, state::Unused;
    pio0_23, PIO0_23, 0, 0x17, state::Unused;
    pio0_24, PIO0_24, 0, 0x18, state::Unused;
    pio0_25, PIO0_25, 0, 0x19, state::Unused;
    pio0_26, PIO0_26, 0, 0x1a, state::Unused;
    pio0_27, PIO0_27, 0, 0x1b, state::Unused;
    pio0_28, PIO0_28, 0, 0x1c, state::Unused;
    pio0_29, PIO0_29, 0, 0x1d, state::Unused;
    pio0_30, PIO0_30, 0, 0x1e, state::Unused;
    pio0_31, PIO0_31, 0, 0x1f, state::Unused;
    pio1_0 , PIO1_0 , 1, 0x00, state::Unused;
    pio1_1 , PIO1_1 , 1, 0x01, state::Unused;
    pio1_2 , PIO1_2 , 1, 0x02, state::Unused;
    pio1_3 , PIO1_3 , 1, 0x03, state::Unused;
    pio1_4 , PIO1_4 , 1, 0x04, state::Unused;
    pio1_5 , PIO1_5 , 1, 0x05, state::Unused;
    pio1_6 , PIO1_6 , 1, 0x06, state::Unused;
    pio1_7 , PIO1_7 , 1, 0x07, state::Unused;
    pio1_8 , PIO1_8 , 1, 0x08, state::Unused;
    pio1_9 , PIO1_9 , 1, 0x09, state::Unused;
    pio1_10, PIO1_10, 1, 0x0a, state::Unused;
    pio1_11, PIO1_11, 1, 0x0b, state::Unused;
    pio1_12, PIO1_12, 1, 0x0c, state::Unused;
    pio1_13, PIO1_13, 1, 0x0d, state::Unused;
    pio1_14, PIO1_14, 1, 0x0e, state::Unused;
    pio1_15, PIO1_15, 1, 0x0f, state::Unused;
    pio1_16, PIO1_16, 1, 0x10, state::Unused;
    pio1_17, PIO1_17, 1, 0x11, state::Unused;
    pio1_18, PIO1_18, 1, 0x12, state::Unused;
    pio1_19, PIO1_19, 1, 0x13, state::Unused;
    pio1_20, PIO1_20, 1, 0x14, state::Unused;
    pio1_21, PIO1_21, 1, 0x15, state::Unused;
);
